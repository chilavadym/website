---
title: Die Rails-Doktrin
permalink: /doctrine/de
redirect_from:
  - /doctrine/en/
---

<div class="heading common-padding--bottom common-padding--top common-shape--bottom-grey-down-left">
  <div class="container">
    <div class="heading__body">
      <div class="heading__headline common-headline">
        <h1>Die Rails-Doktrin.</h1>
      </div>
      <div class="heading__content heading__content--has-headline common-content">
        <dl>
          <dt>David Heinemeier Hansson</dt>
        </dl>
      </div>
      <div class="language">
        <input class="language__checkbox" id="language__checkbox" type="checkbox" role="button" />
        <label class="language__toggle" for="language__checkbox">
          <span>Deutsch</span>
        </label>
        <div class="language__options">
          <ul>
            <li><a href="/doctrine/"><span>English</span></a></li>
            <li><a href="/doctrine/es"><span>Español</span></a></li>
            <li><a href="/doctrine/fr"><span>Français</span></a></li>
            <li><a href="/doctrine/ru"><span>Russian</span></a></li>
            <li><a href="/doctrine/zh_cn"><span>简体中文</span></a></li>
            <li><a href="/doctrine/zh_tw"><span>繁體中文</span></a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="text common-background--grey common-padding--bottom common-padding--top-small common-shape--bottom-white-down-right">
  <div class="container">
    <div class="text__body">
      <div class="text__content common-content">
        <p>Der phänomenale Aufstieg von Ruby on Rails zur Bekanntheit verdankte einen Großteil seines Aufstiegs neuartigen Technologien und Timings. Aber technologische Vorteile schwinden mit der Zeit, und gutes Timing hält Bewegungen allein nicht langfristig aufrecht. Daher ist eine breitere Erklärung dafür erforderlich, wie Rails nicht nur weiterhin relevant bleibt, sondern auch seine Wirkung und Community ausbaut. Ich schlage vor, dass der dauerhafte Wegbereiter seine umstrittene Doktrin war und bleibt.</p>
        <p>Diese Doktrin hat sich in den letzten zehn Jahren weiterentwickelt, aber die meisten ihrer stärksten Säulen sind auch die Gründungspfeiler. Ich erhebe keinen Anspruch auf die grundsätzliche Originalität dieser Ideen. Die Hauptleistung von Rails bestand darin, einen starken Stamm um eine breite Palette ketzerischer Gedanken über die Natur des Programmierens und Programmierer zu vereinen und zu kultivieren.</p>
        <p>Mit all dem Getue folgen hier die neun wichtigsten Säulen der Rails-Doktrin, wie sie von Ihnen wahrgenommen werden:</p>
        <ol>
          <li><a href="#optimize-for-programmer-happiness">Optimieren Sie für die Zufriedenheit der Programmierer</a></li>
          <li><a href="#convention-over-configuration">Konvention über Konfiguration</a></li>
          <li><a href="#omakase">Die Speisekarte ist Omakase</a></li>
          <li><a href="#no-one-paradigm">Kein Paradigma</a></li>
          <li><a href="#beautiful-code">Verherrlichen Sie schönen Code</a></li>
          <li><a href="#provide-sharp-knives">Bieten Sie scharfe Messer an</a></li>
          <li><a href="#integrated-systems">Wertintegrierte Systeme</a></li>
          <li><a href="#progress-over-stability">Fortschritt statt Stabilität</a></li>
          <li><a href="#big-tent">Schieben Sie ein großes Zelt auf</a></li>
        </ol>
      </div>
    </div>
  </div>
</div>

<div id="optimize-for-programmer-happiness" class="text common-padding--bottom common-padding--top">
  <div class="container">
    <div class="text__body">
      <div class="text__content common-content">
        <h3>Optimieren Sie für die Zufriedenheit der Programmierer</h3>
        <p>Es gäbe kein Rails ohne Ruby, daher ist es nur passend, dass die erste Lehrsäule direkt von der Kernmotivation für die Entwicklung von Ruby abgehoben wird.</p>
        <p>Rubys ursprüngliche Ketzerei bestand tatsächlich darin, das Glück des Programmierers auf ein Podest zu stellen. Über vielen anderen konkurrierenden und berechtigten Bedenken, die Programmiersprachen und Ökosysteme zuvor vorangetrieben hatten.</p>
        <p>Während Python damit prahlte, dass es „einen und vorzugsweise nur einen Weg gibt, etwas zu tun“, genoss Ruby Ausdruckskraft und Subtilität. Während Java sich dafür einsetzte, Programmierer energisch vor sich selbst zu schützen, legte Ruby dem Willkommenspaket einen Satz scharfer Messer bei. Wo Smalltalk eine Reinheit der Nachrichtenübermittlung übte, sammelte Ruby Schlüsselwörter und Konstrukte mit einem fast gefräßigen Appetit.</p>
        <p>Ruby war anders, weil es andere Dinge schätzte. Und die meisten dieser Dinge dienten dieser Sehnsucht nach Glück als Programmierer. Eine Verfolgung, die es nicht nur mit den meisten anderen Programmierumgebungen in Konflikt brachte, sondern auch mit der Mainstream-Wahrnehmung dessen, was ein Programmierer ist und wie er handeln sollte.</p>
        <p>Ruby hat es sich zur Aufgabe gemacht, Programmierergefühle nicht nur zu erkennen, sondern zu berücksichtigen und zu fördern. Ob sie aus Unzulänglichkeit, Laune oder Freude stammen. Matz übersprang Implementierungshürden von erstaunlicher Komplexität, um die Maschine dazu zu bringen, ihren menschlichen Mitverschwörer anzulächeln und ihm zu schmeicheln. Ruby steckt voller optischer Täuschungen, bei denen das, was für unser geistiges Auge einfach, klar und schön erscheint, tatsächlich ein akrobatisches Durcheinander von Drähten unter der Motorhaube ist. Diese Entscheidungen waren nicht frei (fragen Sie die JRuby-Crew nach dem Versuch, diese magische Spieluhr zurückzuentwickeln!), Genau deshalb sind sie so lobenswert.</p>
        <p>Es war diese Hingabe an eine alternative Vision für Programmierung und Programmierer, die meine Liebesaffäre mit Ruby besiegelte. Es war nicht nur Benutzerfreundlichkeit, es war nicht nur die Ästhetik der Blöcke, es war keine einzelne technische Errungenschaft. Es war eine Vision. Eine Gegenkultur. Ein Ort, an dem die Außenseiter der bestehenden professionellen Programmierform dazugehören und sich mit Gleichgesinnten verbinden können.</p>
        <p>Ich habe diese Entdeckung von Ruby in der Vergangenheit als das Finden eines magischen Handschuhs beschrieben, der einfach perfekt zu meinem Gehirn passt. Besser als ich mir jemals vorgestellt hatte, dass ein Handschuh jemals passen könnte. Aber es war noch mehr. Es war das Ereignis, das meinen persönlichen Übergang markierte von „Programmieren, weil ich Programme brauchte“ zu „Programmieren, weil ich mich in es als eine Art intellektueller Übung und Ausdruck verliebte“. Es fand eine <a href="http://www.amazon.com/Flow-Harper-Perennial-Modern-Classics-ebook/dp/B000W94FE6/">Quelle des Flusses</a> und war in der Lage, sie nach Belieben einzuschalten. Für jeden, der mit Csikszentmihalyis Arbeit vertraut ist, ist die Wirkung kaum zu überschätzen.</p>
        <p>Ich übertreibe nicht, wenn ich sage, dass Ruby mich verändert und die Weichen für mein Lebenswerk gestellt hat. So tief war die Offenbarung. Es erfüllte mich mit der Berufung, missionarische Arbeit im Dienst von Matz&#39; Schöpfung zu leisten. Um zu helfen, diese tiefgründige Schöpfung und ihre Vorteile zu verbreiten.</p>
        <p>Jetzt kann ich mir vorstellen, dass die meisten von Ihnen ungläubig den Kopf schütteln. Ich mache dir keine Vorwürfe. Wenn mir jemand die obige Erfahrung beschrieben hätte, als ich noch unter dem Paradigma „Programmieren ist nur ein Werkzeug“ lebte, hätte auch ich den Kopf geschüttelt. Und dann hätte ich wahrscheinlich über den übertriebenen Gebrauch religiöser Sprache gelacht. Aber damit dies ein wahrheitsgemäßer Bericht ist, muss er auch ehrlich sein, auch wenn das für einige oder sogar die meisten abschreckend ist.</p>
        <p>Was bedeutete dies für Rails und wie leitet dieses Prinzip weiterhin seine Entwicklung? Um das zu beantworten, denke ich, dass es aufschlussreich ist, sich ein anderes Prinzip anzusehen, das in den frühen Tagen oft verwendet wurde, um Ruby zu beschreiben: das Prinzip der geringsten Überraschung. Ruby sollte sich so verhalten, wie Sie es erwarten würden. Dies lässt sich leicht mit einem Kontrast zu Python beschreiben:</p>
{% highlight ruby %}
$ irb
irb(main):001:0> exit
$ irb
irb(main):001:0> quit

$ python
>>> exit
Use exit() or Ctrl-D (i.e. EOF) to exit
{% endhighlight %}
        <p>Ruby akzeptiert sowohl Beenden als auch Beenden, um dem offensichtlichen Wunsch des Programmierers Rechnung zu tragen, seine interaktive Konsole zu beenden. Python hingegen weist den Programmierer umständlich an, wie er das Gewünschte richtig zu tun hat, obwohl es offensichtlich weiß, was gemeint ist (da es die Fehlermeldung anzeigt). Das ist ein ziemlich klares, wenn auch kleines Beispiel für PoLS.</p>
        <p>Der Grund, warum PoLS bei der Ruby-Community in Ungnade fiel, war, dass dieses Prinzip von Natur aus subjektiv ist. Für wen am wenigsten überraschend? Nun, zu Matz. Und Menschen, die genauso überrascht sind wie er. Als die Ruby-Community wuchs und der Anteil der Leute, die von anderen Dingen als Matz überrascht waren, wuchs, wurde dies zu einer Quelle fruchtloser Bike-Shedding auf den Mailinglisten. Also trat das Prinzip in den Hintergrund, damit es nicht zu weiteren Debatten kam, die nirgendwohin führten, ob Person X von Verhalten Y überrascht war oder nicht.</p>
        <p>Also nochmal, was hat das mit Rails zu tun? Nun, Rails wurde nach einem ähnlichen Prinzip wie das Prinzip der geringsten Überraschung (To Matz) entwickelt. Das Prinzip des größeren Lächelns (von DHH), das ist genau das, was es auf der Dose verspricht: APIs, die mit großer Aufmerksamkeit entwickelt wurden, um alles zu tun, was mich mehr und breiter lächeln lassen würde. Wenn ich das so schreibe, klingt das fast schon komisch narzisstisch, und selbst mir fällt es schwer, gegen diesen ersten Eindruck zu argumentieren.</p>
        <p>Aber so etwas wie Ruby oder Rails zu erschaffen, ist zumindest am Anfang ein zutiefst narzisstisches Unterfangen. Beide Projekte entsprangen dem Kopf eines einzigen Schöpfers. Aber vielleicht projiziere ich hier meine eigenen Beweggründe auf Matz, also lass mich den Umfang meiner Proklamation auf das beschränken, was ich weiß: Ich habe Rails für mich erschaffen. In erster Linie, um mich zum Lächeln zu bringen. Seine Nützlichkeit war in hohem Maße seiner Fähigkeit untergeordnet, mich dazu zu bringen, mein Leben mehr zu genießen. Zur Bereicherung meiner täglichen Arbeit beim Ringen mit Anforderungen und Anfragen für Web-Informationssysteme.</p>
        <p>Wie Matz habe ich manchmal alberne Anstrengungen unternommen, um meinem Prinzip zu dienen. Ein Beispiel ist der Inflector, eine Klasse, die gerade genug von den Mustern und Unregelmäßigkeiten der englischen Sprache versteht, um eine Personenklasse einer Personentabelle, Analysen Analysen und einfach Kommentar Kommentaren zuzuordnen. Dieses Verhalten wird heute als unbestrittenes Element von Rails akzeptiert, aber die Feuer der Kontroversen wüteten mit großer Intensität in den frühen Tagen, als wir noch dabei waren, die Doktrin und ihre Bedeutung zusammenzuführen.</p>
        <p>Ein weiteres Beispiel, das weniger Implementierungsaufwand erforderte, aber fast ebenso viel Bestürzung auslöste: Array#second through #fifth (und #forty_two für eine gute Trolling-Maßnahme). Diese Alias-Zugreifer waren zutiefst beleidigend für eine sehr lautstarke Wählerschaft, die das Aufblähen (und das nahe Ende der Zivilisation, für ein gutes Maß) von etwas beklagte, das genauso gut als Array#[1], Array#[2] (und Array[ 41]).</p>
        <p>Aber beide Entscheidungen bringen mich bis heute zum Schmunzeln. Ich genieße es, people.third in einem Testfall oder der Konsole zu schreiben. Nein, das ist nicht logisch. Es ist nicht effizient. Es kann sogar pathologisch sein. Aber es bringt mich immer noch zum Lächeln, erfüllt damit das Prinzip und bereichert mein Leben, was dazu beiträgt, mein fortgesetztes Engagement bei Rails nach 12 Dienstjahren zu rechtfertigen.</p>
        <p>Anders als beispielsweise die Optimierung auf Leistung ist es schwierig, die Optimierung auf Zufriedenheit zu messen. Dies macht es zu einem fast von Natur aus unwissenschaftlichen Unterfangen, was es für einige weniger wichtig, wenn nicht geradezu frustrierend macht. Programmierern wird beigebracht, das Messbare zu argumentieren und zu erobern. Das, was klare Schlussfolgerungen hat und wo A kategorisch gezeigt werden kann, dass es besser ist als B.</p>
        <p>Aber während das Streben nach Glück auf der Mikroebene schwer zu messen ist, ist es auf der Makroebene viel klarer zu beobachten. Die Ruby on Rails-Community ist voll von Leuten, die genau wegen dieses Strebens hier sind. Sie rühmen sich eines besseren, erfüllteren Arbeitslebens. In dieser Anhäufung von Emotionen ist der Sieg klar.</p>
        <p>Daraus schließen wir: Die Optimierung auf Zufriedenheit ist vielleicht der prägendste Schlüssel zu Ruby on Rails. Dies soll auch in Zukunft so bleiben.</p>
      </div>
    </div>
  </div>
</div>

<div id="convention-over-configuration" class="text common-border--top common-padding--bottom common-padding--top">
  <div class="container">
    <div class="text__body">
      <div class="text__content common-content">
        <h3>Konvention über Konfiguration</h3>
        <p>Eines der frühen Produktivitätsmottos von Rails lautete: „Du bist keine schöne und einzigartige Schneeflocke“. Es postulierte, dass Sie durch das Aufgeben eitler Individualität die Mühsal weltlicher Entscheidungen überspringen und in wirklich wichtigen Bereichen schneller vorankommen können.</p>
        <p>Who cares what format your database primary keys are described by? Does it really matter whether it’s “id”, “postId”, “posts_id”, or “pid”? Is this a decision that’s worthy of  recurrent deliberation? No.</p>
        <p>Part of the Rails’ mission is to swing its machete at the thick, and ever growing, jungle of recurring decisions that face developers creating information systems for the web. There are thousands of such decisions that just need to be made once, and if someone else can do it for you, all the better.</p>
        <p>Not only does the transfer of configuration to convention free us from deliberation, it also provides a lush field to grow deeper abstractions. If we can depend on a Person class mapping to people table, we can use that same inflection to map an association declared as has_many :people to look for a Person class. The power of good conventions is that they pay dividends across a wide spectrum of use.</p>
        <p>But beyond the productivity gains for experts, conventions also lower the barriers of entry for beginners. There are so many conventions in Rails that a beginner doesn’t even need to know about, but can just benefit from in ignorance. It’s possible to create great applications without knowing why everything is the way it is.</p>
        <p>That’s not possible if your framework is merely a thick textbook and your new application a blank piece of paper. It takes immense effort to even figure out where and how to start. Half the battle of getting going is finding a thread to pull.</p>
        <p>The same goes even when you understand how all the pieces go together. When there’s an obvious next step for every change, we can scoot through the many parts of an application that is the same or very similar to all the other applications that went before it. A place for everything and everything in its place. Constraints liberate even the most able minds.</p>
        <p>As with anything, though, the power of convention isn’t without peril. When Rails makes it so trivial to do so much, it is easy to think every aspect of an application can be formed by precut templates. But most applications worth building have some elements that are unique in some way. It may only be 5% or 1%, but it’s there.</p>
        <p>The hard part is knowing when to stray from convention. When are the deviating particulars grave enough to warrant an excursion? I contend that most impulses to be a beautiful and unique snowflake are ill considered, and that the cost of going off the Rails is under appreciated, but just enough of them won’t be that you need to examine all of them carefully.</p>
      </div>
    </div>
  </div>
</div>

<div id="omakase" class="text common-border--top common-padding--bottom common-padding--top">
  <div class="container">
    <div class="text__body">
      <div class="text__content common-content">
        <h3>The menu is omakase</h3>
        <p>How do you know what to order in a restaurant when you don’t know what’s good? Well, if you let the chef choose, you can probably assume a good meal, even before you know what “good” is. That is omakase. A way to eat well that requires you neither be an expert in the cuisine nor blessed with blind luck at picking in the dark.
        <p>For programming, the benefits of this practice, letting others assemble your stack, is similar to those we derive from Convention over Configuration, but at a higher level. Where CoC is occupied with how we best use individual frameworks, omakase is concerned with <em>which</em> frameworks, and how they fit together.
        <p>This is at odds with the revered programming tradition of presenting available tools as individual choices, and to bestow the individual programmer privilege (and burden!) of deciding.
        <p>You’ve surely heard, and probably nodded to, “use the best tool for the job”. It sounds so elementary as to be beyond debate, but being able to pick the “best tool” depends on a foundation that allows “best” to be determined with confidence. This is much harder than it seems.
        <p>It is a problem similar to that of the diner in a restaurant. And like picking each course in an eight-set meal, picking each individual library or framework is not a job done in isolation. The objective in both cases is to consider the whole evening or system.
        <p>So with Rails we decided to diminish one good, a programmer’s individual privilege to choose each tool in their box, for a greater one: A better tool box for all. The dividends are legion:
        <ol>
          <li><strong>There’s safety in numbers:</strong> When most people are using Rails in the same default ways, we have a shared experience. This common ground makes it much easier to teach and help people. It lays a foundation for debate on approach. We all watched the same show last night at 7, so we can talk about it the next day. It fosters a stronger sense of community.</li>
          <li><strong>People are perfecting the same, basic tool box:</strong> As a full-stack framework, Rails has a lot of moving parts, and how those work together is as important as what they do in isolation. Much of the pain in software comes not from the individual components, but from their interaction. When we all work on alleviating shared pain from components that are configured and fail in the same ways, then we all experience less pain.</li>
          <li><strong>Substitutions are still possible, but not required:</strong> While Rails is an omakase stack, it still allows you to replace certain frameworks or libraries with alternatives. It just doesn’t require you to. Which means you can delay those decisions until you’ve developed a clear, personal palette that may prefer the occasional difference.</li>
        </ol>
        <p>Because even the most learned and skilled programmers who come to and stay in Rails aren’t likely opposed to all matters of the menu. (If they were, they probably wouldn’t have stuck with Rails.) So they pick their substitutions with diligence, and then go on to enjoy the rest of the curated, shared stack alongside everyone else.</p>
      </div>
    </div>
  </div>
</div>

<div id="no-one-paradigm" class="text common-border--top common-padding--bottom common-padding--top">
  <div class="container">
    <div class="text__body">
      <div class="text__content common-content">
        <h3>No one paradigm</h3>
        <p>There’s a strong emotional appeal to picking a single central idea and following it to the logical conclusion as your architectural underpinning. There’s a purity in such discipline, so it’s clear why programmers are naturally attracted to this bright light.</p>
        <p>Rails isn’t like that. It isn’t a single, perfect cut of cloth. It’s a quilt. A composite of many different ideas and even paradigms. Many that would usually be seen in conflict, if contrasted alone and one by one. But that’s not what we’re trying to do. It isn’t a single championship of superior ideas where a sole winner must be declared.</p>
        <p>Take the templates we build the view in our Rails MVC pie with. By default, all the helpers that allow us to extract code from these templates are just a big pot of functions! It’s a single namespace even. Oh the shock and the horror, it’s like PHP soup!</p>
        <p>But I contend that PHP had it right when it came to presenting individual functions that rarely needed to interact, as is the case with much abstraction in view templates. And for this purpose, the single namespace, the big pot of methods, is not only a reasonable choice, but a great one.</p>
        <p>This doesn’t mean we don’t occasionally want to reach for something more object-oriented when building views. The concept of Presenters, where we wrap many methods that are interdependent with each other and the data below it, can occasionally be the perfect antidote to a soup of methods turned sour by dependencies. But it’s generally proved to be the rare rather than common fit.</p>
        <p>In comparison, we generally treat the model in our MVC layer cake as the prime bastion of object-oriented goodness. Finding just the right names for objects, increasing the coherence, and lowering the coupling is the fun of domain modeling. It’s a very different layer from the view, so we take a different approach.</p>
        <p>But even here we don’t subscribe to single-paradigm dogma. Rails concerns, the specialization of Ruby’s mixins, are often used to give the individual models a very wide surface area. This fits well with the Active Record pattern by giving the concerned methods direct access to the data and storage they interact with.</p>
        <p>Even the very foundation of the Active Record framework offends some purists. We’re mixing the logic needed for interfacing with the database directly with the business domain and logic. Such conflation of boundaries! Yes, because it proved to be the practical way to skin a web-app cat that virtually always talks to a database of some sort to persist the state of the domain model.</p>
        <p>To be so ideologically flexible is what enables Rails to tackle such a wide array of problems. Most individual paradigms do very well within a certain slice of the problem space, but become awkward or rigid when applied beyond its natural sphere of comfort. By applying many overlapping paradigms, we cover the flanks and guard the rear. The final framework is far stronger and more capable than any individual paradigm would have allowed it to be.</p>
        <p>Now, the cost of this polyamorous relationship with the many paradigms of programming is conceptual overhead. It’s not enough to just know object-oriented programming to have a good time with Rails. It’s preferable to be well served with procedural and functional experiences as well.</p>
        <p>This applies to the many sub-languages of Rails as well. We don’t try to shield you that much from having to learn, say, JavaScript for the view or SQL for the occasional complicated query. At least not to reach the peaks of possibilities.</p>
        <p>The way to alleviate some of that learning burden is to simply just make it easy to get started, make something of real value, before you understand every single aspect of the framework. We have a rush to Hello World for this reason. Your table already prepared and an appetizer served.</p>
        <p>The thinking is that by giving something of real value early, we’ll encourage the practitioners of Rails to level-up quickly. Accept their journey of learning as a joy, not an obstacle.</p>
      </div>
    </div>
  </div>
</div>

<div id="beautiful-code" class="text common-border--top common-padding--bottom common-padding--top">
  <div class="container">
    <div class="text__body">
      <div class="text__content common-content">
        <h3>Exalt beautiful code</h3>
        <p>We write code not just to be understood by the computer or other programmers, but to bask in the warm glow of beauty. Aesthetically pleasing code is a value unto itself and should be pursued with vigor. That doesn’t mean that beautiful code always trumps other concerns, but it should have a full seat at the table of priorities.</p>
        <p>So what is beautiful code? In Ruby, it’s often somewhere at the intersection between native Ruby idioms and the power of a custom domain-specific language. It’s a fuzzy line, but one well worth trying to dance.</p>
        <p>Here’s a simple example from Active Record:</p>
{% highlight ruby %}
class Project < ApplicationRecord
  belongs_to :account
  has_many :participants, class_name: 'Person'
  validates_presence_of :name
end
{% endhighlight %}
        <p>This looks like DSL, but it’s really just a class definition with three class-method calls that take symbols and options. There’s nothing fancy here. But it sure is pretty. It sure is simple. It gives an immense amount of power and flexibility from those few declarations.</p>
        <p>Part of the beauty comes from these calls honoring the previous principles, like Convention over Configuration. When we call belongs_to :account, we’re assuming that the foreign key is called account_id and that it lives in the projects table. When we have to designate the class_name of Person to the role of the participants association, we require just that class name definition. From it we’ll derive, again, the foreign keys and other configuration points.</p>
        <p>Here’s another example from the database migrations system:</p>
{% highlight ruby %}
class CreateAccounts < ActiveRecord::Migration
  def change
    create_table :accounts do |t|
      t.integer :queenbee_id
      t.timestamps
    end
  end
end
{% endhighlight %}
        <p>This is the essence of framework power. The programmer declares a class according to certain convention, like a ActiveRecord::Migration subclass that implements #change, and the framework can do all the plumbing that goes around that, and know this is the method to call.</p>
        <p>This leaves the programmer with very little code to write. In the case of migrations, not only will this allow a call to rails db:migrate to upgrade the database to add this new table, it’ll also allow it to go the other way of dropping this table with another call. This is very different from a programmer making all this happen and stitching the workflow together from libraries they call themselves.</p>
        <p>Sometimes beautiful code is more subtle, though. It’s less about making something as short or powerful as possible, but more about making the rhythm of the declaration flow.</p>
        <p>These two statements do the same:</p>
{% highlight ruby %}
if people.include? person
...
if person.in? people
{% endhighlight %}
        <p>But the flow and focus is subtly different. In the first statement, the focus is on the collection. That’s our subject. In the second statement, the subject is clearly the person. There’s not much between the two statements in length, but I’ll contend that the second is far more beautiful and likely to make me smile when used in a spot where the condition is about the person.</p>
      </div>
    </div>
  </div>
</div>

<div id="provide-sharp-knives" class="text common-border--top common-padding--bottom common-padding--top">
  <div class="container">
    <div class="text__body">
      <div class="text__content common-content">
        <h3>Provide sharp knives</h3>
        <p>Ruby includes a lot of sharp knives in its drawer of features. Not by accident, but by design. The most famous is monkey patching: The power to change existing classes and methods.</p>
        <p>This power has frequently been derided as simply too much for mere mortal programmers to handle. People from more restrictive environments used to imagine all sorts of calamities that would doom Ruby because of the immense trust the language showed its speakers with this feature.</p>
        <p>If you can change anything, what is there to stop you from overwriting String#capitalize so that “something bold”.capitalize returns “Something Bold” rather than “Something bold”? That might work in your local application, but then break all sorts of auxiliary code that depend on the original implementation.</p>
        <p>Nothing, is the answer. There’s nothing programmatically in Ruby to stop you using its sharp knives to cut ties with reason. We enforce such good senses by convention, by nudges, and through education. Not by banning sharp knives from the kitchen and insisting everyone use spoons to slice tomatoes.</p>
        <p>Because the flip side of monkey patching is the power to do such feats of wonder as 2.days.ago (which returns a date two days back from the current). Now you might well think that’s a bad trade. That you’d rather lose 2.days.ago if it means preventing programmers from overwriting String#capitalize. If that’s your position, Ruby is probably not for you.</p>
        <p>Yet it’d be hard — even for people who would give up such freedom for some security — to argue that the power to change core classes and methods has doomed Ruby as a language. On the contrary, the language flourished exactly because it offered a different and radical perspective on the role of the programmer: That they could be trusted with sharp knives.</p>
        <p>And not only trusted, but taught in the ways to use such capable tools. That we could elevate the entire profession by assuming most programmers would want to become better programmers, capable of wielding sharp knives without cutting off their fingers. That’s an incredibly aspirational idea, and one that runs counter to a lot of programmer’s intuition about other programmers.</p>
        <p>Because it’s always about other programmers when the value of sharp knives is contested. I’ve yet to hear a single programmer put up their hand and say “I can’t trust myself with this power, please take it away from me!”. It’s always “I think other programmers would abuse this”. That line of paternalism has never appealed to me.</p>
        <p>That brings us to Rails. The knives provided by the framework are not nearly as sharp as those offered with the language, but some are still plenty keen to cut. We will make no apologies for offering such tools as part of the kit. In fact, we should celebrate having enough faith in the aspirations of our fellow programmers to dare trust them.</p>
        <p>Plenty of features in Rails have been contested over time as being “too much freedom”. But one example that’s currently in vogue is <a href="https://github.com/rails/rails/blob/master/activesupport/lib/active_support/concern.rb">the feature of concerns</a>. This is a thin layer of syntactic sugar around Ruby’s built-in feature of modules and is designed to allow a single class to encapsulate multiple related but independently understood concerns (hence the name).</p>
        <p>The charge is that concerns provide programmers prone to bloat their objects with a whole new set of drawers to stuff their clutter in. And that’s true. Concerns can indeed be used like that.</p>
        <p>But the grand fallacy is thinking that by <i>not</i> providing a feature like concerns, which when used by even mildly capable hands allows an eloquent partial separation of concepts, we’d put programmers on the path to architectural bliss. If you can’t be trusted to keep the kitchen sink out of your overstuffed concerns, you’re probably not going to end up with a shining beacon of elegance otherwise.</p>
        <p>Programmers who haven’t learned to wield sharp knifes just aren’t going to make meringues yet. Operative word here: Yet. I believe that every programmer has a path, if not a right, to become fully capable Ruby and Rails programmers. And by capable, I mean knowledgeable enough to know when and how, accordingly to their context, they should use the different and sometimes dangerous tools in the drawers.</p>
        <p>That does not abdicate a responsibility to help get them there. The language and the framework should be patient tutors willing to help and guide anyone to experthood. While recognizing that the only reliable course there goes through the land of mistakes: Tools used wrong, a bit of blood, sweat, and perhaps even some tears. There simply is no other way.</p>
        <p>Ruby on Rails is an environment for chefs and those who wish to become chefs. You might start out doing the dishes, but you can work your way up to running the kitchen. Don’t let anyone tell you that you can’t be trusted with the best tool in the trade as part of that journey.</p>
      </div>
    </div>
  </div>
</div>

<div id="integrated-systems" class="text common-border--top common-padding--bottom common-padding--top">
  <div class="container">
    <div class="text__body">
      <div class="text__content common-content">
        <h3>Value integrated systems</h3>
        <p>Rails can be used in many contexts, but its first love is the making of integrated systems: Majestic monoliths! A whole system that addresses an entire problem. This means Rails is concerned  with everything from the front-end JavaScript needed to make live updates to how the database is migrated from one version to another in production.</p>
        <p>That’s a very broad scope, as we’ve discussed, but no broader than to be realistic to understand for a single person. Rails specifically seeks to equip generalist individuals to make these full systems. Its purpose is not to segregate specialists into small niches and then require whole teams of such in order to build anything of enduring value.</p>
        <p>It is this focus on empowering the individual that points to the integrated system. It’s in the integrated system we can cut out many needless abstractions, reduce the duplication between layers (like templates on both the server and the client), and, above all, avoid distributing our system before we absolutely, positively have to.</p>
        <p>Much of the complication in systems development comes from introducing new boundaries between the elements that restrict how you make calls between A and B. Method calls between objects is far simpler than remote procedure calls between microservices. There’s a whole new world of hurt in failure states, latency issues, and dependency update schedules that await those who venture into the lair of distribution.</p>
        <p>Sometimes this distribution is simply necessary. If you want to create an API to your web application that other people can call over HTTP, well, then you just have to suck it up and deal with many of these issues (although handling requests inbound rather than sending them outbound is much easier – your downtime is someone else’s failure state!). But that’s at least a limited amount of damage inflicted on your own personal development experience.</p>
        <p>What’s worse is when systems are prematurely disintegrated and broken into services or, even worse, microservices. This drive frequently starts from the misconception that if you want a Modern Internet Application, you’ll simply have to build the systems many times over: Once on the server side, once on the JavaScript MVC client-side, once for each of the native mobile applications, and so forth. This is not a law of nature, it needn’t be so.</p>
        <p>It’s entirely possible to share large chunks of the entire application across multiple apps and accesses. To use the same controllers and views for the desktop web as for embedded in native mobile apps. To centralize as much as possible within that glorious, majestic monolith: The integrated system.</p>
        <p>All this without giving up much if anything in terms of speed, user experience, or other attributes that falsely draw developers to premature distribution.</p>
        <p>That’s the have-most-of-it-all we seek: All the power of individually tuned and distributed applications with the ease-of-use and understanding of a single, integrated system.</p>
      </div>
    </div>
  </div>
</div>

<div id="progress-over-stability" class="text common-border--top common-padding--bottom common-padding--top">
  <div class="container">
    <div class="text__body">
      <div class="text__content common-content">
        <h3>Progress over stability</h3>
        <p>When systems have been around for more than a decade, like Rails has, their natural tendency is towards ossification. There are a million reasons why every change might be an issue for someone, somewhere who depended on past behavior. And fair reasons those are too, for the individual.</p>
        <p>But if we listen too closely to the voices of conservatism, we’ll never see what’s on the other side. We have to dare occasionally break and change how things are to evolve and grow. It is this evolution that’ll keep Rails fit for survival and prosperity in the decade(s?) to come.</p>
        <p>This is all easy to understand in theory, but much harder to swallow in practice. Especially when it’s your application that breaks from a backwards-incompatible change in a major version of Rails. It’s at those times we need to remember this value, that we cherish progress over stability, to give us the strength to debug the busted, figure it out, and move with the times.</p>
        <p>That’s not a license to inflict needless or excessive hurt willy nilly. The Great Rails Migration of 2.x to 3 still lingers in the scar tissue of many who were around for that. It was a tough one. A serious upheaval that left many behind in 2.x land for a long time, some soured beyond convincing. But, in the grand scheme of things, it was still worth it.</p>
        <p>Those are the hard bargains we have to continue to make. Is Rails going to be better off in five years for the changes we make today? Is Rails going to be better off for adopting another problem domain, like job queuing or WebSockets, in years to come? If yes, then let’s suck it up and do the work.</p>
        <p>This work isn’t just something that needs to happen in Rails itself, but also in the larger Ruby community. Rails should be at the frontier of helping Ruby’s progress by driving its constituents to adopt later versions faster. </p>
        <p>We’ve done very well at this so far. From when I started, we’ve moved through Ruby 1.6, 1.8, 1.9, 2.0, 2.1, 2.2, 2.3, 2.4, 2.5 and now onto 2.6. Lots of major changes along the way, but Rails was there to have Ruby’s back, and help everyone get with the program faster. That’s in part the privilege and obligation Rails serves as the major popularizer of Ruby.</p>
        <p>This too is true for the auxiliary tools of the chain. Bundler was once a controversial idea, but through Rails’ insistence that it be a cornerstone of a shared future, it’s today just taken for granted. The same is true for things like the asset pipeline and Spring, the persistent command process. All three of these went through, or are still going through, growing pains, but the obviousness of their value in the long term helped us push through that.</p>
        <p>Progress is ultimately mostly about people and their willingness to push change. This is why there are no lifetime seats in groups like <a href="/community#core">Rails Core</a> or <a href="/community#committers">Rails Committers</a>. Both groups are for those who are actively working on making progress for the framework. For some, their stake in such progress may last just a few years, and we will forever be grateful for their service, and for others it may last decades.</p>
        <p>Likewise, it’s why it’s so important for us to continue to welcome and encourage new members of the community. We need fresh blood and fresh ideas to make better progress.</p>
      </div>
    </div>
  </div>
</div>

<div id="big-tent" class="text common-border--top common-padding--bottom common-padding--top">
  <div class="container">
    <div class="text__body">
      <div class="text__content common-content">
        <h3>Push up a big tent</h3>
        <p>With so many controversial ideas to its credit, Rails could quickly become an insular group of ideological hermits, if we required everyone to exhibit complete deference to all tenets, all the time. So we don’t!</p>
        <p>We need disagreement. We need dialects. We need diversity of thought and people. It’s in this melting pot of ideas we’ll get the best commons for all to share. Lots of people chipping in their two cents, in code or considered argument.</p>
        <p>So while this doctrine has described an idealized form, the everyday reality is much more nuanced (and interesting). Rails is capable of supporting such a large community under one tent exactly because there are so few if any litmus tests. </p>
        <p>The continued success of RSpec, a DSL for testing I’ve often expressed grave discontent with, is perfect proof. I can rant until I’m blue in the face of why I don’t think it’s the way to go, and it can still blossom and prosper. That point is the far more important one!</p>
        <p>The same is true for the advent of Rails as an API. While my personal focus and dedication is to the integrated system that includes the view, there’s undoubtedly room for Rails to do well with people who do want to distribute their clients and servers upfront. We should embrace this inasmuch as it can coexist as a secondary mission, and I believe it surely can.</p>
        <p>Having a big tent doesn’t mean trying to be all things to all people, though. It just means you welcome all people to your party, and allow them to bring their own drinks. We need to lose none of our soul or values by offering others to join us, and we may well learn how to mix a new delicious drink or two.</p>
        <p>This doesn’t come for free. It requires work to be welcoming. Especially if your goal isn’t just to attract more people who are just like the ones who are already part of the community. Lowering the barriers to entry is work we should always take seriously.</p>
        <p>You never know when the next person who starts just fixing a misspelling in the documentation ends up implementing the next great feature. But you stand a chance to find out if you smile and say thank you for whatever small contribution that gets the motivation flowing.</p>
      </div>
    </div>
  </div>
</div>
